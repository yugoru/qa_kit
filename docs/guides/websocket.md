# QA Kit — WebSocket сервис

Этот гайд поможет быстро начать работать с WebSocket-сервисом в составе **QA Kit**.

---

## 1) Зачем нужен этот сервис

WebSocket даёт **двусторонний канал связи** между клиентом и сервером.
В QA Kit он нужен, чтобы потренировать:

* real-time коммуникацию
* сценарии «один запрос → несколько ответов»
* комнаты/каналы
* сочетание WebSocket + REST
* корреляцию сообщений через `request_id`
* (опционально) событийность через Kafka и наблюдаемость через Kibana

---

## 2) Где он работает

По умолчанию сервис доступен локально на порту **8002**:

* REST: `http://localhost:8002`
* WS: `ws://localhost:8002/ws`

Подключение к каналу:

* `ws://localhost:8002/ws?channel=general`

Если канал не указан, используется дефолтный.

---

## 3) REST-эндпойнты

Сервис имеет несколько простых REST-ручек (удобно для тестов):

1. **Health-check**

   * `GET /health`
   * Проверяет, что сервис жив.

2. **Статистика подключений**

   * `GET /stats`
   * Показывает количество активных соединений по каналам.

3. **Broadcast через HTTP**

   * `POST /broadcast?message=...&channel=...`
   * Отправляет сообщение всем клиентам указанного канала.

---

## 4) WebSocket протокол

Сервис работает по учебному JSON-протоколу.

### 4.1. Общий формат запроса клиента

```json
{
  "action": "...",
  "payload": {"...": "..."},
  "request_id": "any-string"
}
```

* **action** — тип команды
* **payload** — данные команды
* **request_id** — идентификатор для корреляции ответов

---

### 4.2. Общие типы ответов сервера

Сервер может прислать несколько сообщений в ответ на одно действие:

1. **ack** — подтверждение получения

```json
{
  "type": "ack",
  "request_id": "abc-1",
  "ts": "..."
}
```

2. **data** — полезные данные

3. **event** — событийное сообщение

Это сделано специально для тренировки сценария:

> один запрос → несколько ответов

---

## 5) Поддерживаемые action

### 5.1. `echo`

Возвращает подтверждение + эхо-данные + событие.

Пример запроса:

```json
{
  "action": "echo",
  "payload": {"text": "hello"},
  "request_id": "r-echo-1"
}
```

Ожидаемый паттерн ответов:

* `ack`
* `echo`
* `event ws.echo`

---

### 5.2. `triplet_demo`

Демонстрация «1 → 3».

```json
{
  "action": "triplet_demo",
  "payload": {},
  "request_id": "r-triplet-1"
}
```

Ожидается:

* `ack`
* `step 1`
* `step 2`
* `event ws.triplet_demo`

---

### 5.3. `broadcast`

Отправляет сообщение всем клиентам текущего канала.

```json
{
  "action": "broadcast",
  "payload": {"message": "hi all"},
  "request_id": "r-bc-1"
}
```

---

### 5.4. `get_order` (если включена интеграция с Postgres)

Возвращает заказ по ID.

```json
{
  "action": "get_order",
  "payload": {"id": 1},
  "request_id": "r-order-1"
}
```

Ожидается:

* `ack`
* `order` с данными (или `data: null`)
* `event order.viewed`

---

### 5.5. `list_orders` (если включена интеграция с Postgres)

Возвращает несколько последних заказов.

```json
{
  "action": "list_orders",
  "payload": {},
  "request_id": "r-orders-1"
}
```

Ожидается:

* `ack`
* `orders` со списком
* `event order.listed`

---

## 6) Полезные идеи из старой версии протокола (адаптировано)

Раньше в учебном WS для заказов встречались команды вроде `ping`, `create_order`, `change_status`, `get_order` и широковещательные события `order_created`, `order_status_changed`.

В текущей версии сервиса формат действий другой, но **идея тестов остаётся той же**. Ниже — как эти сценарии выглядят теперь.

### 6.1. Проверка соединения (аналог Ping)

Используйте `echo` или просто отправьте любую команду и убедитесь, что первым приходит `ack`.

Пример:

```json
{
  "action": "echo",
  "payload": {"text": "ping"},
  "request_id": "r-ping-1"
}
```

Ожидаемо:

* `ack`
* `echo`
* `event ws.echo`

### 6.2. Создание заказа

В текущем WS-сервисе создание заказа может быть реализовано отдельно (в зависимости от вашей версии стенда).
Если у вас пока нет `create_order` в WS, этот сценарий можно показать через REST API заказов, а в WS проверить **реакцию на событие** или выполнить тесты чтения `list_orders/get_order`.

### 6.3. Изменение статуса заказа

Сценарий из старой инструкции очень полезен для тест-дизайна:

* created → paid / cancelled
* paid → shipped / cancelled
* shipped → delivered

Если в вашей версии WS добавлен `change_status`, то ожидайте:

1. `ack`
2. `order`/`result`-сообщение
3. `event order.status_changed` или аналогичное событие

Если `change_status` пока нет — тестируйте эти переходы через REST и проверяйте, что WS-клиенты получают broadcast/события.

### 6.4. Ошибки формата и неизвестные команды

Эта часть полностью актуальна как учебная идея:

* невалидный JSON
* неизвестный `action`
* отсутствие обязательных полей

Ожидайте ответ типа `error` с понятным описанием проблемы и сохранённым `request_id`, если он был передан.

### 6.5. Широковещательные события

Откройте 2 WS-клиента в одном канале и проверьте:

* `broadcast` из одного клиента виден второму
* `POST /broadcast` отправляет сообщение всем в канале

---

## 6) Как протестировать быстро

### 6.1. Через Postman

1. Создай **New → WebSocket Request**
2. Вставь:

   * `ws://localhost:8002/ws?channel=general`
3. Подключись
4. Отправь JSON-команду, например `triplet_demo`.

Важно:

* Это обычный WS, **TLS не нужен**.

---

### 6.2. Через два клиента

Подключи 2 вкладки Postman (или 2 клиента).
Оба — в один и тот же канал.
Отправь `broadcast` из одного клиента.

Ожидаемо:

* сообщение увидят оба.

---

### 6.3. Через REST broadcast

```bash
curl -X POST "http://localhost:8002/broadcast?message=hello&channel=general"
```

---

## 7) Наблюдаемость (если включено в вашем стенде)

### 7.1. Логи

Сервис пишет события в stdout контейнера.

```bash
docker logs qa_websocket --tail 200
```

### 7.2. Kibana

Если настроен Filebeat → Elasticsearch:

* Открой **Discover**
* Выбери data view `filebeat-*`
* Фильтр по контейнеру:

  * `container.name : "qa_websocket"`

### 7.3. Kafka

Если включена отправка событий:

* Открой Kafka UI
* Найди топик (например) `ws_events`
* Проверь, что появляются события `ws.echo`, `order.viewed` и т.д.

---

## 8) Типичные ошибки

1. **Нет сообщений в канале**

   * Проверь time range в Discover
   * Проверь, что Filebeat запущен без ошибки прав

2. **WS подключение не устанавливается**

   * Проверь порт `8002` в `docker ps`
   * Проверь логи `qa_websocket`

3. **`get_order` всегда возвращает null**

   * Убедись, что в БД есть записи
   * Проверь `DATABASE_URL` у websocket-сервиса

---

## 9) Что важно понять концептуально

* WebSocket — это не «ещё один REST», а **постоянное соединение**.
* Сервер может **инициировать сообщения** сам (broadcast/события).
* `request_id` помогает тестировать сложные последовательности ответов.
* События в Kafka — это следующий шаг к архитектуре «сервис → шина → подписчики».

---

## 10) Мини-чек-лист для тестировщика

* [ ] WS handshake работает
* [ ] Подключение с `channel` и без него
* [ ] `echo` возвращает ожидаемый набор сообщений
* [ ] `triplet_demo` даёт 3 ответа
* [ ] `broadcast` виден всем клиентам канала
* [ ] `/stats` корректно отражает количество подключений
* [ ] (опц.) `get_order/list_orders` читают данные из Postgres
* [ ] (опц.) события видны в Kafka
* [ ] (опц.) логи видны в Kibana
